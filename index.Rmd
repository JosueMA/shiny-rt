---
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
runtime: shiny
---

<!--
TO DO NOW:
 * DATASETS
   * Change theoretical distributions to be more idiosyncratic
   * Add Mental Rotation dataset or similar with long response times.
   
 * CHEAT SHEET:
   * Make a checklist table / cheat sheet for all distributions, rather than the pros/cons.
   * Make a frequentist column as well (e.g., for gamma and normal). Add to text too!
   
 * TEXT:
   * Is a shift parameter neccessary? Trunk behavior can do a lot of it.
   * Think about "trunk" name.
   * Maybe score if the *value* of the parameter has some straight-forward interpretation.
   * More info about inverse gaussian?
   * RUN THROUGH GRAMMARLY OR SIMILAR SPELL CHECKER!
   * Add icons to shift + trunk + spread

 * Publish it online and check mobile!

 * PLOTS:
   * Challenge: move just one slider to match different RT.

-->

```{r, echo=FALSE}
# Set it up:
# install.packages('brms')
# install.packages('RWiener')
# install.packages('shiny')
# install.packages('rtdists')
library(brms)
library(shiny)
library(rtdists)

# SETTINGS
FIG_HEIGHT = 290
TRIM_MIN = 0.2
TRIM_MAX = 2
RESOLUTION = 1024  # Number of points to evaluate densities at
NSAMPLES = 10000  # Number of samples for theoretical distributions
UPDATE_INTERVAL = 1000  # ms between each applet checking for updates in dataset

# Score as scaled mean squared difference between empirical and theoretical density
# This score is a bit arbitrary, but it should be good enough
score_fit = function(rt_type, dfun) {
  #rts = rt_data  # Get the relevant data
  empirical_density = density(rt_data, from=0, to=TRIM_MAX, n = 1024, bw=0.02)$y  # From actual observations
  theoretical_density = dfun(seq(1/RESOLUTION, TRIM_MAX, length.out = 1024))  # From density function. Start at 1 so invgauss doesn't fail
  round(mean((theoretical_density - empirical_density)^2) * 10000)  # Mean squares. Scaled and rounded to digestible number
}


# Show a plot, theoretical density, and score
show_plot = function(input, dfun = NULL) {
  # Histogram
  par(mar = c(5, 0, 0, 0) + 0.1)
  hist(rt_data, breaks=seq(0, TRIM_MAX, TRIM_MAX/100), xlim=c(0, TRIM_MAX), 
       freq = FALSE, 
       axes = FALSE,  # To remove y-axis, we need to remove both first...
       xlab = 'Reaction Time', ylab = NULL, main = NULL)
  axis(1)  # Add x-axis
  
  if(!is.null(dfun)) {
    # Add theoretical curve
    curve(dfun, add=TRUE, lwd=2, col='red')
    
    # Present score as legend
    error = score_fit(input$rt_type, dfun)
    legend(
      'topright',
      inset = 0.05,
      # = 1,
      #y = 2,
      cex = 2,
      box.col = NA,
      bg = NA,
      
      # Set text and text color based on error
      text.col = ifelse(error < 40, '#AA9944', ifelse(
        error < 150, '#00BB00', ifelse(error > 300, '#BB0000', 'black')
      )),
      legend = paste0('Mismatch: ', error, ifelse(error < 40, '\nNailed it!', ''))
    )
  }
}
```


<!-- Generate datasets -->
```{r, echo=FALSE}
data("rr98")
data("speed_acc")

rt_types = c(
  # Real RTs
  'Brightness discrimination (Ratcliff & Rouder, 1998)' = 'rr98',
  'Discriminate words/non-words - be accurate (Wagenmakers et al., (2008)' = 'accuracy',
  'Discriminate words/non-words - be fast (Wagenmakers et al., (2008)' = 'speed',
  
  # Theoretical RTs
  'Gaussian (Normal distribution)' = 'gauss',
  'Ex-gaussian' = 'exgauss',
  'Wiener diffusion' = 'wiener',
  'Inverse Gaussian (Wald)' = 'invgauss',
  'log-normal' = 'slog',
  'Skew-normal' = 'skew',
  'Gamma' = 'gamma',
  'Weibull' = 'sweibull'
)

last_data_update = Sys.time()  # For init
update_data = function(rt_type) {
  last_data_update <<- Sys.time()
  # Typical use case: choose by label
  if(is.character(rt_type)) {
    set.seed(42)
    rt_data = switch(rt_type,
      # Real datasets
      'accuracy' = filter(speed_acc, condition == 'accuracy', id == 3)$rt,
      'speed' = filter(speed_acc, condition == 'speed', id == 3)$rt,
      'rr98' = filter(rr98, correct == TRUE, id == 'nh', source == 'light')$rt,
      
      # Theoretical datasets
      'gauss' = rnorm(NSAMPLES, mean=0.7, sd=0.2),
      'exgauss' = rexgaussian(NSAMPLES, mu=0.65, sigma=0.1, beta=0.25),
      'wiener' = rwiener(NSAMPLES, alpha=2, tau=0.2, beta=0.4, delta=3)$q,
      'invgauss' = rshifted_inv_gaussian(NSAMPLES, mu=0.6, shape=5, shift=0),
      #'log' = rlnorm(NSAMPLES, meanlog=-0.6, sdlog=0.3),
      'slog' = rshifted_lnorm(NSAMPLES, meanlog=-0.6, sdlog=0.3, shift=0),
      'skew' = rskew_normal(NSAMPLES, mu=0.6, sigma=0.2, alpha=6),
      'gamma' = rgamma(NSAMPLES, shape=11, rate=19),
      #'weibull' = rweibull(NSAMPLES, shape=3.5, scale=0.6),
      'sweibull' = rshifted_weibull(NSAMPLES, shape=3.5, scale=0.6, shift=0)
    )
  # But one can also insert one's own data:
  } else if(is.numeric(rt_type)) {
    rt_data = rt_type
  }
  
  # Make sure that it stays within bounds, and assign to global scope
  rt_data <<- rt_data[ifelse(rt_data < TRIM_MIN | rt_data > TRIM_MAX, FALSE, TRUE)]
}

import_rts = function(rt_string) {
  
}
```


# Types of parameters
A few types of parameters occur frequently. We will use the presense and absence of these parameters as one (of several) criterions to evaluate how good a distribution is.

 * **Shift:** moves the whole distribution to the left or right without altering its shape. This is sometimes called *non-decision time* in models where the value of the shift reflect the earliest recorded RTs. No animal can percieve or respond in 0.0 ms, so it's good to have a shift parameter.
 * **Trunk:** models the time at which the bulk of RTs are recorded (highest density, e.g., the mean, median, or mode). One dominant feature of RTs is that the spread increases with the mean [(Wagenmakers et al., 2007)](http://ejwagenmakers.com/2007/WagenmakersBrown2007.pdf) so a parameter has to do this to qualify as a trunk parameter.
 * **Spread:** Narrows or widens the timeframe within which RTs are recorded over and beyond the behavior of the *trunk* parameter, i.e., without (severely) affecting the mean/median/mode. This probably scales with the *uncertainty* associated with the task, e.g., through interference.

Try yourself to drag some sliders below to see this behavior. When one parameter does only one of these jobs, you can model differences between experimental conditions in a non-ambiguous way. For parameters that does more than one of the above, I will distinguish between:

 * **Mechanism:** has a clear mechanistic interpretation motivated by theory.
 * **Messy:** not motivated by theory.

And here are our two commandments:

<!-- Make this a proper quote -->

    * Messy parameters are bad.
    * If you have no mechanism parameters, you should have ashift, trunk, AND a spread.



# Select data

```{r, echo=FALSE}
shinyApp(
  ui = fluidPage(
    # Select or input data
    fluidRow(
      column(7, selectInput('rt_type', label = 'Choose a dataset:', choices = rt_types, selected = 'accuracy', width = '100%')),
      column(5, textInput('rts_input', label = '... or paste your own RTs:', width='100%'))
    ),
    
    # Trim on one line
    div(style="display: inline-block;vertical-align:top;", numericInput('trim_min', label = 'Min RT', value=0.180, min=0, max=10, step=0.1, width='80px')),
    div(style="display: inline-block;vertical-align:top;", numericInput('trim_max', label = 'Max RT', value=2.0, min=0, max=10, step=0.1, width='80px')),
    
    # Placeholder for histogram
    fluidRow(
      plotOutput('plot_select', height='100%')
    )
  ),
  
  
  # Set dataset
  server = function(input, output) {
    output$plot_select = renderPlot(height=FIG_HEIGHT, expr = {
      TRIM_MIN <<- input$trim_min
      TRIM_MAX <<- input$trim_max
      
      # If custom data has been pasted, parse it to vector.
      if(input$rts_input != '') {
        update_data(rt_type = as.numeric(strsplit(input$rts_input, '[;, ]+')[[1]]))
      }
      
      # Else just set data by label
      else {
        update_data(rt_type = input$rt_type)
      }
      
      # Finally! Show the plot
      show_plot(input)
    })
  },
  
  options = list(height=580)
)
```


# Drag those sliders!
Now go through the distributions below and notice what happens when you drag the sliders. The "Error" is the mean squared difference times 10.000.


## Gaussian (normal distribution) {#gauss}
This models responses from a single mean with a symmetrical dispersion towards faster and slower RTs. The normal distribution is, in most cases, the worst distribution to fit reaction times. For example, for typical reaction times, you will end up predicting that more than 5% of the reaction times will be *negative*! Yet, the Gaussian is by far the most frequently used analysis of reaction times because most statistical packages and software defaults to the Gaussian. For example, t-tests, ANOVA, linear regression, `lm`, `lme4::lmer`, and `brms::brm`. Also, if you pre compute means for each participant or condition and use *those* in your stats, you've subscribed to the Gaussian model (and throwed away a lot of wonderful data). 

**Parameters**

 * $\mu$ (**shift**): the mean.
 * $\sigma$ (**spread**): the standard deviation. This models (symmetric) variability in RTs.


Fit it using `brms::brm(rt ~ 1, ..., family=gaussian())`. Most packages use the Gaussian by default.

<hr />

```{r, echo=FALSE}
gauss_i = 0
shinyApp(
  ui = fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "gauss_mu", label = NULL, pre='<i>&mu;</i> = ',
                    min = 0, max = 3, value = 1, step = 0.01),
        sliderInput(inputId = 'gauss_sigma', label = NULL, pre='<i>&sigma;</i> = ',
                    min = 0, max = 1, step = 0.01, value = 0.4)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  server = function(input, output, session) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      gauss_i <<- gauss_i + 1
      print(gauss_i)
      pollData()  # Update plot if global data was changed
      dfun = function(x) dnorm(x, input$gauss_mu, input$gauss_sigma)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=520)
)
```



## Ex-gaussian {#exgauss}
If you believe that response originale as a mix of two independent processes, (1) a [Gaussian](#gauss) and (2) a decaying exponential, the ex-gaussian is exactly this. Most people don't believe this, but use the ex-gaussian in a purely descriptive way because it usually has an excellent fit to RTs. The exponential part requires just one extra parameter in addition to the Gaussian. See [Wikipedia](https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution).


**Parameters:**

* $\mu$ (**shift**): the mean of the gaussian. This models shorter/longer mean RTs.
* $\sigma$ (**spread**): the standard deviation of the gaussian. This models (symmetric) variability in RTs.
* $\lambda$ (**messy**): the decay rate of the exponential. This models the tail of long RTs. Higher $\lambda$ --> more tail dominance over the Gaussian.

Fit it using `brms::brm(rt ~ 1, ..., family=exgaussian())`.


```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "exgauss_mu", label = NULL, pre='<i>&mu;</i> = ',
                    min = 0, max = 3, value = 1, step = 0.01),
        sliderInput(inputId = 'exgauss_sigma', label = NULL, pre='<i>&sigma;</i> = ',
                    min = 0, max = 1, step = 0.01, value = 0.15),
        sliderInput(inputId = 'exgauss_lambda', label = NULL, pre='<i>&lambda;</i> = ',
                    min = 0, max = 2, step = 0.01, value = 0.3)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) brms::dexgaussian(x, input$exgauss_mu, input$exgauss_sigma, input$exgauss_lambda)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=590)
)
```




## Wiener diffusion {#wiener}
Also called the *Diffusion Decision Model (DDM)*, this is probably the most popular model focused at *mechanisms*. It applies to two-alternative forced-choice (2afc) scenarios and requires data on *accuracy* as well (scored as correct/wrong). It models RTs as a decision being made when a random walker crosses one of two thresholds (boundary). It's clear mechanistic interpretability is a strength, but it requires some effort to understand and do. Read [Ratcliff & McKoon (2008)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2474742/) for a motivation for the model. I like [this visalization](https://images.app.goo.gl/b31JzswrSQK1f5zf8).


**Parameters:**

 * $\alpha$ (**trunk** and **mechanism**): Boundary separation. The distance between thresholds. Longer distance --> longer and more dispersed RT before walker crosses threshold.
 * $\tau$ (**shift** and **mechanism**): Non-decision time (ndt). The time at which the random walker starts.
 * $\beta$ (**trunk** and **mechanism**): Bias. How close the walker starts to the upper threshold ($\beta = 0.5$ is in the middle). Higher = closer = faster and more condensed RTs.
 * $\delta$ (**trunk** and **mechanism**): Drift Rate. The speed of the walker. Higher --> faster and more condensed RTs.

See [this three-part brms tutorial](http://singmann.org/wiener-model-analysis-with-brms-part-i/) by Henrik Singman on how to fit it and do regression on the parameters. It usually takes days or weeks to fit, but [Wagenmakers (2007)](https://www.ejwagenmakers.com/2007/EZ.pdf) made the [EZ diffusion calculator](https://www.ejwagenmakers.com/EZ.html) which approximates the parameters in the simplest scenario. The [HDDM python package](http://ski.clps.brown.edu/hddm_docs/) can do it as well.


```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "wiener_alpha", label = "Boundary separation", pre='<i>&alpha;</i> = ',
                    min = 0.5, max = 3, value = 1.5, step = 0.01),
        sliderInput(inputId = 'wiener_tau', label = 'Non-decision time', pre='<i>&tau;</i> = ',
                    min = 0, max = 1, step = 0.01, value = 0.4),
        sliderInput(inputId = 'wiener_beta', label = 'Bias', pre='<i>&beta;</i> = ',
                    min = 0, max = 1, step = 0.01, value = 0.3),
        sliderInput(inputId = 'wiener_delta', label = 'Drift rate', pre='<i>&delta;</i> = ',
                    min = -1, max = 4, step = 0.01, value = 1.5)
      ),
  
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) brms::dwiener(x, input$wiener_alpha, input$wiener_tau, input$wiener_beta, input$wiener_delta)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=750)
)
```




## (Shifted) Inverse Gaussian {#invgauss}
... also known as the *(Shifted) Wald*. It is not as "inverse" of the Gaussian as it sounds, and is a purely descriptive distribution. Read more on [Wikipedia](https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution)


**Parameters:**

 * $\mu$ (**trunk**)
 * $shape$ (**messy**)
 * $shift$ (**shift**): time of earliest possible response. When $shift = 0$ it is a plain *Inverse Gaussian* or *Wald* distribution, i.e., only two parameters.

Fit the (non-shifted) inverse Gaussian using `brms::brm(rt ~ 1, ..., family=inverse.gaussian()`.


```{r, echo=FALSE}
# Density and radnom generation for (Shifted) Inverse Gaussian / (Shifted) Wald.
dshifted_inv_gaussian = function(x, mu, shape, shift) {
  dens = dinv_gaussian(x - shift, mu, shape)
  dens[is.na(dens)] = 0  # NaN means 0 density during shift.
  dens
}
rshifted_inv_gaussian = function(n, mu, shape, shift) shift + dinv_gaussian(n, mu, shape)

# Shiny!
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "sinvgauss_mu", label = NULL, pre='<i>&mu;</i> = ',
                    min = 0, max = 2, value = 0.8, step = 0.01),
        sliderInput(inputId = 'sinvgauss_shape', label = NULL, pre='shape = ',
                    min = 0, max = 15, value = 4, step = 0.1),
        sliderInput(inputId = 'sinvgauss_shift', label = NULL, pre='shift = ',
                    min = 0, max = 2, value = 0, step = 0.01)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) dshifted_inv_gaussian(x, input$sinvgauss_mu, input$sinvgauss_shape, input$sinvgauss_shift)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=590)
)
```




## (Shifted) Log-normal {#slog}
When using logarithms, you model *percentage increase or decrease* instead of absolute differences. That is, rather than saying "RTs are 40 ms slower in incongruent trials", your parameter(s) say that "RTs are 7% slower in incongruent trials". This embodies the intuition that a difference of 40 ms can be huge for simple reaction times but insignificant for RTs around 10 seconds. Mathematically it is about *multiplicative* relationships rather than *additive* relationships, and this makes some sense when talking about RTs, so I'd say that the shifted log-normal is somewhere between being descriptive and mechanistic. In general, log-like models [makes a lot of sense for most positive-only variables](https://statmodeling.stat.columbia.edu/2019/08/21/you-should-usually-log-transform-your-positive-data/) like RT.

It's called "log-normal" because the parameters are the mean and sd of the log-transformed RTs, which is assumed to be a normal (Gaussian) distribution. For example, for simple RTs you will often see an intercept near `exp(-1.5) = 0.22 seconds`.


**Parameters:**

 * $\mu$ (**trunk**): the mean of the log-normal distribution. The mean of $\mu$ represents the median RT. The median RT is then $shift + exp(\mu)$.
 * $\sigma$ (**spread**): the standard deviation of the log-normal distribution.
 * $shift$ (**shift**): time of the earliest possible response. When $shift = 0$, it's a straight-up *log-normal distribution* with two parameters.

Fit it using `brms::brm(rt ~ 1, ..., family = shifted_lognormal())`.


```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      sidebarPanel(
        width=4,
        sliderInput(inputId = 'slog_mu', label = NULL, pre='<i>&mu;</i> = ',
                    min = -2, max = 2, step = 0.05, value = -0.6),
        sliderInput(inputId = 'slog_sigma', label = NULL, pre='<i>&sigma;</i> = ',
                    min = 0, max = 2, step = 0.01, value = 0.6),
        sliderInput(inputId = "slog_shift", label = NULL, pre='shift = ',
                    min = 0, max = 1.5, value = 0, step = 0.01)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) brms::dshifted_lnorm(x, input$slog_mu, input$slog_sigma, input$slog_shift)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=590)
)
```




## Skew normal {#skew}
Adds a skew to the normal (Gaussian) distribution via an extra skew-parameter. In my experience, it usually has a poorer fit to reaction times, though it is superior to the Gaussian.

**Parameters:**

 * $\mu$ (**shift**): the mean.
 * $\sigma$ (**spread**): the standard deviation. Changing $\sigma$ preserves the mean $\mu$ but not the median. Note that when $\alpha \neq 0$, the distribution is not symmetric, so the don't interpret it like the SD of a normal distribution.
 * $\alpha$ (**messy**): the skewness. When $\alpha = 0$, it's a Gaussian.
 
Fit it using `brms::brm(rt ~ 1, ..., family=skew_normal()`.

```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "skew_mu", label = NULL, pre='<i>&mu;</i> = ',
                    min = 0, max = 3, value = 1, step = 0.01),
        sliderInput(inputId = 'skew_sigma', label = NULL, pre='<i>&sigma;</i> = ',
                    min = 0, max = 1, step = 0.01, value = 0.3),
        sliderInput(inputId = 'skew_alpha', label = NULL, pre='<i>&alpha;</i> = ',
                    min = -15, max = 15, step = 0.1, value = 3.5)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) brms::dskew_normal(x, input$skew_mu, input$skew_sigma, input$skew_alpha)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=590)
)
```



## Gamma {#gamma}
The gamma distribution is so important in statistics, that it probably spilled over to RT research as well. Although it can fit the data, it's very hard to intepret the parameters in relation to RTs, and I will have little more to say. One could easily make a shifted Gamma, but I haven't seen it used for the analysis of reaction times.

**Parameters:**

Both parameters in isolation are **trunk**-like and their interaction determines **spread**. I think that this makes them **messy**.

 * $shape$ (**messy**)
 * $rate$ (**messy**)
 
Fit it using `brms::brm(rt ~ 1, ..., family=gamma()`.

```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "gamma_shape", label = NULL, pre='shape = ',
                    min = 0, max = 50, value = 5, step = 0.1),
        sliderInput(inputId = 'gamma_rate', label = NULL, pre='rate = ',
                    min = 0, max = 50, value = 10, step = 0.1)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) dgamma(x, input$gamma_shape, input$gamma_rate)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=520)
)
```





## (Shifted) Weibull {#sweibull}
... also called the *three-parameter Weibull* when there is a shift parameter. The Weibull is very much like the [inverse Gaussian](#invgauss) and the same comments apply.

**Parameters:**

 * $shape$ (**messy**)
 * $scale$ (**messy**)
 * $shift$ (**shift**): when $shift = 0$, it's a straight-up *Weibull distribution* with the above two parameters.

Fit it using `brms::brm(rt ~ 1, ..., family=weibull())`.

```{r, echo=FALSE}
# Density and random generation for three-parameter Weibull
dshifted_weibull = function(x, shape, scale, shift) dweibull(x - shift, shape, scale)
rshifted_weibull = function(n, shape, scale, shift) shift + rweibull(n, shape, scale)

# Shiny!
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        sliderInput(inputId = "sweibull_shape", label = NULL, pre='shape = ',
                    min = 0, max = 10, value = 2.2, step = 0.1),
        sliderInput(inputId = 'sweibull_scale', label = NULL, pre='scale = ',
                    min = 0, max = 2, value = 0.5, step = 0.01),
        sliderInput(inputId = 'sweibull_shift', label = NULL, pre='shift = ',
                    min = 0, max = 2, value = 0, step = 0.01)
      ),
      
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      dfun = function(x) dshifted_weibull(x, input$sweibull_shape, input$sweibull_scale, input$sweibull_shift)
      show_plot(input, dfun)
    })
  },
  
  options = list(height=600)
)
```




## Linear Ballistic Accumulator {#lba}
This model has some resemblance to the [Wiener diffusion model](#wiener) in that it models latent "movements" towards decision thresholds, and is very much focused on *mechanisms*. It likewise applies to two-alternative forced-choice (2afc) scenarios, requiring data on accuracy as well (correct/incorrect response). Although it involves a lot of parameters, the model itself is (at least supposed to be) simpler than the diffusion model [as explained in Brown & Heathcote (2008)](https://linkinghub.elsevier.com/retrieve/pii/S0010-0285(07)00072-2). A nice visualization from that paper [escaped the paywall here](https://www.semanticscholar.org/paper/The-simplest-complete-model-of-choice-response-Brown-Heathcote/6a23d45269edd7783fa6edd8c469ca8fb5d53ac6/figure/4).

**Parameters:**

* $A$: upper bound of the starting point. The starting point is modeled as randomly drawn in this interval.
* $b$: response threshold (usually, $b > A$).
* $t0$ (**shift**): the time before a "movement" is initiated, i.e., *non-decision time*.
* $mean\_v$: the mean drift rate and it's variability (SD).
* $sd\_v$: the mean standard devation of the drift rate and *it's* variability (SD)

Fit it using `glba::lba()`. There are some helpful distributions in the `rtdists` package.

```{r, echo=FALSE}
shinyApp(
  fluidPage(
    sidebarLayout(
      # Sliders
      sidebarPanel(
        width=4,
        
        sliderInput(inputId = "lba_A", label = NULL, pre='A = ',
                    min = 0, max = 2, value = 1, step = 0.01),
        sliderInput(inputId = 'lba_b', label = NULL, pre='b = ',
                    min = 1, max = 10, value = 2, step = 0.05),
        sliderInput(inputId = 'lba_t0', label = NULL, pre='t0 = ',
                    min = -1, max = 2.5, value = 0.2, step = 0.01),
        sliderInput(inputId = 'lba_drift_mm', label = NULL, pre='mean(mean_v) = ',
                    min = 0, max = 10, value = 3, step = 0.1),
        sliderInput(inputId = 'lba_drift_msd', label = NULL, pre='sd(mean_v) = ',
                    min = 0, max = 6, value = 1, step = 0.1),
        sliderInput(inputId = 'lba_drift_sdm', label = NULL, pre='mean(sd_v) = ',
                    min = 0, max = 6, value = 1, step = 0.1),
        sliderInput(inputId = 'lba_drift_sdsd', label = NULL, pre='sd(sd_v) = ',
                    min = 0, max = 6, value = 1, step = 0.1)
      ),
  
      # Placeholder for histogram
      mainPanel(width=8, plotOutput(outputId = "histogram", height='100%'))
    )
  ),
  
  # Render histogram on server
  function(input, output) {
    # Check every second whether global data was updated
    pollData = reactivePoll(UPDATE_INTERVAL, session,
      function() last_data_update,
      function() ''
    )
    
    # Render plot
    output$histogram = renderPlot(height=FIG_HEIGHT, expr = {
      pollData()  # Update plot if global data was changed
      
      # Density for LBA
      dfun = function(x) {
        rtdists::dLBA(
          x,
          response = 1,
          A = input$lba_A,
          b = input$lba_b,
          t0 = input$lba_t0,
          mean_v = c(input$lba_drift_mm, input$lba_drift_msd),
          sd_v = c(input$lba_drift_sdm, input$lba_drift_sdsd),
          silent = TRUE
        )
      }
      show_plot(input, dfun)
    })
  },
  
  options = list(height=900)
)
```